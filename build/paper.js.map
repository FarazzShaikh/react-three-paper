{"version":3,"file":"paper.js","sources":["../index.tsx"],"sourcesContent":["import React, { useEffect, useRef, useCallback, useState } from \"react\";\n\ntype tPaperRenderLoop = (time?: number) => void;\ntype tPaperCleanup = () => void;\n\ntype tPaperScriptReturn = {\n  render: tPaperRenderLoop;\n  cleanup?: tPaperCleanup;\n};\n\ntype tPaperScript = (canvas?: HTMLCanvasElement) => Promise<tPaperScriptReturn>;\ntype tPaperPositionEvent = (entry: IntersectionObserverEntry) => void;\ntype tPaperErrorEvent = (error: Error) => void;\n\ninterface iPaperPropTypes {\n  script: tPaperScript;\n  onExit?: tPaperPositionEvent;\n  onEntry?: tPaperPositionEvent;\n  onError?: tPaperErrorEvent;\n  style?: React.CSSProperties;\n}\n\nconst IntersectionObserverOptions = {\n  threshold: 0.01,\n};\n\nexport function Paper({ script, style, onExit, onEntry, onError }: iPaperPropTypes) {\n  const ref = useRef(null);\n  const [scriptReturn, setScriptReturn] = useState(null as tPaperScriptReturn);\n\n  const execScript = useCallback(async (promise: Promise<tPaperScriptReturn>, callback: tPaperErrorEvent) => {\n    try {\n      const r = await promise;\n      setScriptReturn(r);\n    } catch (error) {\n      callback(error);\n    }\n  }, []);\n\n  useEffect(() => {\n    let ID: number = 0;\n\n    if (scriptReturn === null) {\n      execScript(script(ref.current), (error: Error) => {\n        console.error(error);\n        cancelAnimationFrame(ID);\n        if (onError) onError(error);\n      });\n    } else {\n      const { render, cleanup } = scriptReturn;\n\n      function animate(time: number) {\n        render(time);\n        ID = requestAnimationFrame(animate);\n      }\n\n      let observer = new IntersectionObserver(([entry]) => {\n        const { isIntersecting } = entry;\n        if (isIntersecting) {\n          if (onEntry) onEntry(entry);\n          ID = requestAnimationFrame(animate);\n        } else {\n          if (onExit) onExit(entry);\n          cancelAnimationFrame(ID);\n        }\n      }, IntersectionObserverOptions);\n\n      observer.observe(ref.current);\n\n      return () => {\n        observer.disconnect();\n        if (cleanup) cleanup();\n      };\n    }\n  }, [script, ref, scriptReturn]);\n\n  return (\n    <canvas\n      ref={ref}\n      style={{\n        width: \"100%\",\n        height: \"100%\",\n        ...style,\n      }}\n    />\n  );\n}\n"],"names":["IntersectionObserverOptions","threshold","Paper","script","style","onExit","onEntry","onError","ref","useRef","scriptReturn","setScriptReturn","useState","execScript","useCallback","async","promise","callback","r","error","useEffect","ID","render","cleanup","animate","time","requestAnimationFrame","observer","IntersectionObserver","entry","isIntersecting","cancelAnimationFrame","observe","current","disconnect","console","React","width","height"],"mappings":"gFAsBA,MAAMA,EAA8B,CAClCC,UAAW,cAGGC,GAAMC,OAAEA,EAAMC,MAAEA,EAAKC,OAAEA,EAAMC,QAAEA,EAAOC,QAAEA,IACtD,MAAMC,EAAMC,EAAO,OACZC,EAAcC,GAAmBC,EAAS,MAE3CC,EAAaC,GAAYC,MAAOC,EAAsCC,KAC1E,IACE,MAAMC,QAAUF,EAChBL,EAAgBO,GAChB,MAAOC,GACPF,EAASE,MAEV,IAuCH,OArCAC,GAAU,KACR,IAAIC,EAAa,EAEjB,GAAqB,OAAjBX,EAMG,CACL,MAAMY,OAAEA,EAAMC,QAAEA,GAAYb,EAE5B,SAASc,EAAQC,GACfH,EAAOG,GACPJ,EAAKK,sBAAsBF,GAG7B,IAAIG,EAAW,IAAIC,sBAAqB,EAAEC,MACxC,MAAMC,eAAEA,GAAmBD,EACvBC,GACExB,GAASA,EAAQuB,GACrBR,EAAKK,sBAAsBF,KAEvBnB,GAAQA,EAAOwB,GACnBE,qBAAqBV,MAEtBrB,GAIH,OAFA2B,EAASK,QAAQxB,EAAIyB,SAEd,KACLN,EAASO,aACLX,GAASA,KA5BfV,EAAWV,EAAOK,EAAIyB,UAAWd,IAC/BgB,QAAQhB,MAAMA,GACdY,qBAAqBV,GACjBd,GAASA,EAAQY,QA4BxB,CAAChB,EAAQK,EAAKE,IAGf0B,0BACE5B,IAAKA,EACLJ,MAAO,CACLiC,MAAO,OACPC,OAAQ,UACLlC"}